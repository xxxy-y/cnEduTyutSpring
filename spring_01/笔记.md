1. Spring中的IoC容器管理的接口本身还是接口实现类呢？

   答：Spring中的IoC容器管理的是接口实现类，而不是接口本身，接口本身并没有被Spring容器直接管理。相反，Spring容器只关注接口实现类，并为其创建实例并进行管理。
2. 在Spring的IoC容器中管理的是接口实现类，那为什么要使用`UserService userServiceImpl = (UserService) applicationContext.getBean("userService");`来获取IoC容器中管理的接口实现类，而不直接使用`UserServiceImpl userServiceImpl = applicationContext.getBean("userService");`呢？
   
   答：定义为接口是为了实现面向接口编程的原则。面向接口编程可以提高代码的灵活性和可扩展性。 当我们将接口作为类型来定义变量时，可以在需要的时候使用不同的实现类来实例化这个变量。这样，我们可以通过更改配置文件或使用不同的实现类来改变代码的行为，而不需要修改代码本身。 另外，使用接口可以将代码模块化，使其更易于测试和维护。接口定义了类之间的契约，让开发人员可以根据这个契约来编写代码，而不需要依赖具体的实现细节。这样，不同的开发人员可以独立开发不同的实现类，而无需了解彼此的具体实现细节。
3. 调用创建的接口实现类`userServiceImpl`时，会使用`UserService`接口中的方法和属性，还是`userServiceImpl`中的方法和属性呢？

   答：调用userServiceImpl时，会使用userServiceImpl中的方法和属性，而不是UserService接口中的方法和属性。
   虽然userServiceImpl是通过UserService接口来定义的，但它是接口的具体实现类，拥有自己的方法和属性。
   
   当通过接口类型来定义变量并实例化对象时，实际上创建的是具体实现类的对象。因此，在使用userServiceImpl对象时，可以调用具体实现类中定义的方法和属性。
4. 在xml文件中定义bean时，有两个属性为`<bean name="user1" class="User1">`和`<bean id="user1" class="User1">`，其中id和name的用法一样吗？
   
   答：id属性是用于唯一标识bean，而name属性是用于给bean定义一个或多个名称。
   
   id属性：id属性用于给当前bean定义一个唯一的标识符。它通常用于在Spring容器中获取该bean的实例。每个bean定义都应该有一个唯一的id属性，以便于在应用程序中引用该bean。

   name属性：name属性用于给当前bean定义一个或多个名称。这些名称可以用来在应用程序中引用该bean。name属性允许在命名上更加灵活，可以使用逗号、分号等多种分隔符来指定多个名称，甚至可以使用通配符来指定一组bean名称。
5. 容器中只要注册了对应类的Bean和是对应类型子类的Bean，都可以获取到
   Student student01 = context.getBean(Student.class);
6. 默认情况下，通过IoC容器进行管理的Bean都是单例模式的，这个对象只会被创建一次.如果我们希望每次拿到的对象都是一个新的，我们也可以将其作用域修改为`prototype`，一共有两种作用域，第一种是singleton，默认情况下就是这一种，当然还有prototype，表示为原型模式（为了方便叫多例模式也行）这种模式每次得到的对象都是一个新的。当Bean的作用域为单例模式时，那么它会在一开始（容器加载配置时）就被创建，我们之后拿到的都是这个对象。而处于原型模式下，只有在获取时才会被创建，也就是说，单例模式下，Bean会被IoC容器存储，只要容器没有被销毁，那么此对象将一直存在，而原型模式才是相当于在要用的时候直接new了一个对象，并不会被保存。

   当然，如果我们希望单例模式下的Bean不用再一开始就加载，而是一样等到需要时再加载（加载后依然会被容器存储，之后一直使用这个对象了，不会再创建新的）我们也可以开启懒加载。开启懒加载后，只有在真正第一次使用时才会创建对象。

   因为单例模式下Bean是由IoC容器加载，但是加载顺序我们并不清楚，如果我们需要维护Bean的加载顺序（比如某个Bean必须要在另一个Bean之前创建）那么我们可以使用depends-on来设定前置加载Bean，这样被依赖的Bean一定会在之前加载
7. 使用构造方法来实现依赖注入的话，其中的name是指构造函数中的参数名称。

   使用setter方法来实现依赖注入的话，其中的name是指该类中的属性名称。
8. 当使用setter方法注入时，需要满足两个条件：第一个为必须有无参构造函数；第二个为必须要属性的setter方法。
9. 当创建子类Bean时，会先创建父类的Bean。